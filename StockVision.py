# -*- coding: utf-8 -*-
"""ai_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ALIGMHtJsqtwx9yWFnyS1jjM18fYHnvq

Inventory Prediction model based on season in fashion store.

[Kaggle dataset link](https://www.kaggle.com/datasets/paramaggarwal/fashion-product-images-small/data)

[Google Drive dataset link](https://drive.google.com/file/d/1LhRcBBWplwOaPUtv9j-ekjuI-2Ic9fsF/view?usp=sharing)


This model helps fashion stores to make informed descision about the inventory count required for a particular article type in various seasons.

First an article - season model is trained wihich predicts the season for an article type.

This output is also passed as one of the input to Inventory count prediction model

Following are inputs and targets for inventory prediction model:

Input features:

1. Gender
2. Season
3. Brand
4. Article type(shirts, jeans, etc)
5. Output of Article-Season prediction model

Target:
1. Inventory Count

**Run the code and enter the inputs for each input(season, gender, article, brand) with reference to possible inputs printed when executed.**
"""

from google.colab import drive
!pip install gdown
import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder, StandardScaler
import tensorflow as tf
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt

file_id = "1LhRcBBWplwOaPUtv9j-ekjuI-2Ic9fsF"
gdown_url = f"https://drive.google.com/uc?id={file_id}"
!gdown {gdown_url} -O styles.csv


# uploaded = files.upload()
# Load data
data = pd.read_csv('styles.csv').dropna()

# First model - Article to Season prediction
def train_article_season_model(data):
    """Train the first model that predicts season from article type"""

    # Clean and prepare data
    data['articleType'] = data['articleType'].str.strip()
    data['season'] = data['season'].str.strip().fillna('Unknown')

    # Initialize and fit label encoders
    le_season = LabelEncoder()
    le_article = LabelEncoder()

    # Encode categorical variables
    data['season_encoded'] = le_season.fit_transform(data['season'])
    data['article_encoded'] = le_article.fit_transform(data['articleType'])

    # Prepare features and target
    X = data[['article_encoded']]
    y = data['season_encoded'].values

    # Scale features and target
    scaler_X = StandardScaler()
    scaler_y = StandardScaler()

    X_scaled = scaler_X.fit_transform(X)
    y_scaled = scaler_y.fit_transform(y.reshape(-1, 1)).ravel()

    # Split data
    X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_scaled, test_size=0.2, random_state=42)

    # Define and compile model
    model = tf.keras.Sequential([
        tf.keras.layers.Dense(32, activation='relu', input_shape=(1,)),
        tf.keras.layers.BatchNormalization(),
        tf.keras.layers.Dropout(0.2),
        tf.keras.layers.Dense(16, activation='relu'),
        tf.keras.layers.BatchNormalization(),
        tf.keras.layers.Dropout(0.2),
        tf.keras.layers.Dense(8, activation='relu'),
        tf.keras.layers.Dense(1)
    ])

    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
                 loss='mse',
                 metrics=['mae'])

    # Train model
    history = model.fit(
        X_train,
        y_train,
        validation_split=0.2,
        epochs=100,
        batch_size=32,
        verbose=0
    )

    # Get predictions for all articles
    article_season_pred = model.predict(X_scaled).flatten()  # Flatten the predictions

    return article_season_pred, history, model, scaler_X, scaler_y, le_article, le_season

# Second model - Inventory prediction
def prepare_inventory_data(data):
    """Prepare data for inventory prediction"""

    # Process brand and inventory data
    data['productDisplayName'] = data['productDisplayName'].str.strip()
    data['brand'] = data['productDisplayName'].apply(lambda x: str(x).strip().split()[0])
    data['brand_article'] = data['brand'] + " " + data['articleType']

    # Calculate inventory counts
    inventory_counts = data['brand_article'].value_counts()
    data['inventoryCount'] = data['brand_article'].map(inventory_counts)

    # Remove duplicates after counting
    data = data.drop_duplicates(subset=['brand_article'])

    # Clean categorical variables
    data['season'] = data['season'].str.strip().dropna()
    data['gender'] = data['gender'].str.strip().dropna()
    data['articleType'] = data['articleType'].str.strip().dropna()
    data['brand'] = data['brand'].dropna()

    return data

def train_inventory_model(data, article_season_pred):
    """Train the second model that predicts inventory"""

    # Prepare data
    data = prepare_inventory_data(data)

    # Initialize and fit label encoders
    le_season = LabelEncoder()
    le_gender = LabelEncoder()
    le_article = LabelEncoder()
    le_brand = LabelEncoder()

    # Store unique values
    unique_values = {
        'seasons': sorted(data['season'].unique()),
        'genders': sorted(data['gender'].unique()),
        'articles': sorted(data['articleType'].unique()),
        'brands': sorted(data['brand'].unique())
    }

    # Encode categorical variables
    encoded_data = {
        'season': le_season.fit_transform(data['season']),
        'gender': le_gender.fit_transform(data['gender']),
        'article': le_article.fit_transform(data['articleType']),
        'brand': le_brand.fit_transform(data['brand'])
    }

    # Prepare features and target
    X = np.column_stack((
        encoded_data['season'],
        encoded_data['gender'],
        encoded_data['article'],
        encoded_data['brand'],
        article_season_pred[:len(data)],
        article_season_pred[len(data):2*len(data)],
        article_season_pred[2*len(data):3*len(data)],
        article_season_pred[3*len(data):4*len(data)],
        article_season_pred[4*len(data):5*len(data)],

    ))
    y = data['inventoryCount'].values

    # Scale features and target
    scaler_X = StandardScaler()
    scaler_y = StandardScaler()

    X_scaled = scaler_X.fit_transform(X)
    y_scaled = scaler_y.fit_transform(y.reshape(-1, 1)).ravel()

    # Split data
    X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_scaled, test_size=0.2, random_state=42)

    # Define and compile model
    model = tf.keras.Sequential([
        tf.keras.layers.Dense(32, activation='relu', input_shape=(9,)),  # Changed from 5 to 9
        tf.keras.layers.BatchNormalization(),
        tf.keras.layers.Dropout(0.2),
        tf.keras.layers.Dense(16, activation='relu'),
        tf.keras.layers.BatchNormalization(),
        tf.keras.layers.Dropout(0.2),
        tf.keras.layers.Dense(8, activation='relu'),
        tf.keras.layers.Dense(1)
    ])

    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
                 loss='mse',
                 metrics=['mae'])

    # Add logging callback
    class TrainingLogger(tf.keras.callbacks.Callback):
        def on_epoch_end(self, epoch, logs=None):
            if (epoch + 1) % 50 == 0:  # Print every 50 epochs
                print(f"\nEpoch {epoch + 1}")
                print(f"Training Loss: {logs['loss']:.4f}")
                print(f"Validation Loss: {logs['val_loss']:.4f}")

    # Train model
    history = model.fit(
        X_train,
        y_train,
        validation_split=0.2,
        epochs=250,
        batch_size=32,
        callbacks=[TrainingLogger()],
        verbose=0
    )

    # Evaluate the model on the test set
    test_loss, test_mae = model.evaluate(X_test, y_test, verbose=0)
    print(f"Test MAE: {test_mae:.4f}")

    return (model, history, scaler_X, scaler_y,
            le_season, le_gender, le_article, le_brand,
            unique_values)

class InventoryPredictor:
    def __init__(self, data_path='styles.csv'):
        # Load data
        self.data = pd.read_csv(data_path)
        data['season']=self.data['season'].dropna()
        # Train first model
        print("Training article-season model...")
        (self.article_season_pred, _, self.article_season_model,
         self.article_scaler_X, self.article_scaler_y,
         self.article_le, self.season_le) = train_article_season_model(self.data)

        # Train second model
        print("Training inventory prediction model...")
        (self.inventory_model, _, self.inventory_scaler_X,
         self.inventory_scaler_y, self.le_season, self.le_gender,
         self.le_article, self.le_brand,
         self.unique_values) = train_inventory_model(self.data, self.article_season_pred)

        print("Models trained successfully!")

    def predict_inventory(self, season, gender, article_type, brand):
        """Predict inventory count for given inputs"""
        try:
            # Encode inputs
            season_enc = self.le_season.transform([season])[0]
            gender_enc = self.le_gender.transform([gender])[0]
            article_enc = self.le_article.transform([article_type])[0]
            brand_enc = self.le_brand.transform([brand])[0]

            # Get article-season prediction
            article_feature = np.array([[article_enc]])
            article_scaled = self.article_scaler_X.transform(article_feature)
            season_pred = float(self.article_season_pred[article_enc])

            # Prepare input features with all 9 features
            input_features = np.array([[
                float(season_enc),
                float(gender_enc),
                float(article_enc),
                float(brand_enc),
                season_pred,
                season_pred,  # Using the same prediction for additional features
                season_pred,
                season_pred,
                season_pred,

            ]])

            # Scale input features
            input_scaled = self.inventory_scaler_X.transform(input_features)

            # Predict inventory
            predicted_inventory_scaled = self.inventory_model.predict(input_scaled)
            predicted_inventory = self.inventory_scaler_y.inverse_transform(predicted_inventory_scaled)

            return max(1, int(predicted_inventory[0][0]))

        except Exception as e:
            print(f"Error during prediction: {str(e)}")
            return None
if __name__ == "__main__":
    predictor = InventoryPredictor('styles.csv')

F'gs'

def interactive_prediction():
        """Run interactive prediction loop"""
        while True:
            print("\nAvailable options:")
            print("Seasons:", predictor.unique_values['seasons'])
            print("Genders:", predictor.unique_values['genders'])
            print("Article Types:", predictor.unique_values['articles'])
            print("Brands:", predictor.unique_values['brands'])

            season_input = input("\nEnter season: ").strip()
            gender_input = input("Enter gender: ").strip()
            article_input = input("Enter article type: ").strip()
            brand_input = input("Enter brand: ").strip()

            predicted_inventory = predictor.predict_inventory(
                season_input, gender_input, article_input, brand_input
            )

            if predicted_inventory is not None:
                print(f"\nPredicted inventory count for {brand_input} {article_input} "
                      f"({season_input}, {gender_input}): {predicted_inventory} items")
            else:
                print("Invalid input, please try again.")

            if input("\nMake another prediction? (y/n): ").lower() != 'y':
                break

# Main execution
interactive_prediction()